{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#quartile-api","title":"Quartile API","text":"<p>Grow your product sales with Quartile\u2019s e-commerce advertising solutions across Amazon, Instacart, and other leading online marketplaces.</p> <p>Site Quartile </p>"},{"location":"index.html#about-documentation","title":"About Documentation","text":"<p>Welcome to the Quartile API documentation. You'll find tutorials, tips, and extra documentation on using the Developer Portal, tokens, and more.</p> <p>Our APIs are currently documented using the OpenAPI standard; if you have questions about API endpoints, you can access the Developer Portal and go to the endpoint you want to learn more about.</p>"},{"location":"index.html#check-api-connection","title":"Check API Connection","text":"<p>Change the \"{{sub_key}}\" to your subscriber key.  If you don't have a subscriber key, you can create one in the Developer Portal.</p> <p>Developer Portal </p> v1v2 <p></p><pre><code>$ curl \"https://api.quartile.com/status/v1?subscription-key={{sub_key}}\"\n{\n    \"message\": \"running\"\n}\n</code></pre> <p></p><pre><code>$ curl \"https://api.quartile.com/status/v2?subscription-key={{sub_key}}\"\n{\n    \"message\": \"running\"\n}\n</code></pre>"},{"location":"changes-v1-to-v2.html","title":"Changes","text":""},{"location":"changes-v1-to-v2.html#v2","title":"v2","text":"<p>To standardize endpoints and make them simpler to use, in v2, we made some changes to endpoint input and output contracts. There are several changes between v1 and v2!</p> <ul> <li>Changed: means that the endpoint has changed in some way.</li> <li>Endpoint: means that the path has changed.</li> <li>Json(In/Out): means that the input and output contracts have changed.</li> </ul> <p>Note</p> <p>The ~ means that the endpoint is not available in v1. But it is available in v2.</p> <p>Background processing</p> <p>In v2, some endpoints may receive new features; for example, on patch endpoints that end with <code>/batch</code> you can send a list of resources to process in the background in a single request, then use the get <code>/batch/{id}</code> to check the status of the processing.</p> <p>Batch processing is an excellent way to reduce the number of requests.</p> <p>The batch processing is limited to 100 resources per request and the items needs to be unique.</p> <p>After you send a batch request, you can check the status of the processing using the get <code>/batch/{id}</code> endpoint. </p> <p>The status code and status can be:</p> <ul> <li><code>206-PENDING</code>: the batch is in the queue waiting to be processed.</li> <li><code>206-RUNNING</code>: the batch is being processed.</li> <li><code>206-PARTIAL</code>: the batch has been processed partially.</li> <li><code>206-FAILED</code>: the batch has failed to be processed completely.</li> <li><code>200-SUCCESS</code>: the batch has been processed successfully.</li> </ul>"},{"location":"changes-v1-to-v2.html#oauth-api","title":"OAuth API","text":"<p>Now the OAuth API v2 has a new endpoint called <code>/login</code> used to authenticate the user and return the access and refresh tokens.  This endpoint is not available in v1.</p> <p>The <code>/token</code> endpoint is deprecated in v2. It is still available in v1 but will be removed in the future.</p> <p>In v1, the first authentication is necessary to get access and refresh tokens on the Quartile Dev Portal. But now, in v2, you can use the <code>/login</code> endpoint to authenticate the user and get the tokens.</p> <p>The username and password are the same as the ones used to log in on the Quartile Portal.</p>"},{"location":"changes-v1-to-v2.html#auth","title":"Auth","text":"<p>Path: <code>/auth/{version}</code></p> Methods /v1 /v2 Changed Endpoint Json(In/Out) <code>GET</code> /token deprecated <code>POST</code> /refresh-token /refresh <code>POST</code> /validate-token /validate <code>POST</code> ~ /login"},{"location":"changes-v1-to-v2.html#amazon-api","title":"Amazon API","text":"<p>The Amazon API has new changes in v2. You can see the changes in the table below.</p> <p>All endpoints now add, change or remove only one resource at a time. This means that the input and output contracts are now different from the ones in v1. You can see the changes in the table below.</p>"},{"location":"changes-v1-to-v2.html#root","title":"Root","text":"<p>Path: <code>/amazon/{version}</code></p> Methods v1 v2 Changed Endpoint Json(In/Out) <code>GET</code> /accounts /accounts"},{"location":"changes-v1-to-v2.html#pipe","title":"Pipe","text":"<p>Path: <code>/amazon/{version}/pipe</code></p> Methods v1 v2 Changed Endpoint Json(In/Out) <code>GET</code> /campaigns /campaigns <code>GET</code> /adgroup /adgroup <code>GET</code> /target /target <code>GET</code> /keyword /keyword <code>GET</code> /reports /reports/{reportId} <code>POST</code> /reports /reports"},{"location":"changes-v1-to-v2.html#process","title":"Process","text":"<p>Path: <code>/amazon/{version}/process</code></p> Methods v1 v2 Changed Endpoint Json(In/Out) <code>GET</code> /masterlist /masterlist <code>POST</code> /masterlist /masterlist <code>GET</code> ~ /masterlist/{id} <code>PUT</code> /masterlist /masterlist/{id} <code>DELETE</code> /masterlist /masterlist/{id} <code>PATCH</code> ~ /masterlist/batch <code>GET</code> ~ /masterlist/batch/{id} <code>GET</code> /campaignsstatus /campaigns-status <code>POST</code> /campaignsstatus /campaigns-status"},{"location":"changes-v1-to-v2.html#parameters","title":"Parameters","text":"<p>Path: <code>/amazon/{version}/parameters</code></p> Methods v1 v2 Changed Endpoint Json(In/Out) <code>GET</code> /products /products/acos <code>POST</code> /products /products/acos <code>GET</code> ~ /products/acos/{id} <code>PUT</code> /products /products/acos/{id} <code>DELETE</code> /products /products/acos/{id} <code>GET</code> ~ /products/acos/history <code>GET</code> /campaigns /campaigns/acos <code>POST</code> /campaigns /campaigns/acos <code>GET</code> ~ /campaigns/acos/{id} <code>PUT</code> /campaigns /campaigns/acos/{id} <code>DELETE</code> /campaigns /campaigns/acos/{id}"},{"location":"changes-v1-to-v2.html#products","title":"Products","text":"<p>Path: <code>/amazon/{version}/products</code></p> Methods v1 v2 Changed Endpoint Json(In/Out) <code>GET</code> /tag /tags <code>GET</code> ~ /tags/{id} <code>PUT</code> /tag /tags/{id} <code>GET</code> /info /info <code>POST</code> /info /info <code>GET</code> ~ /info/{id} <code>PUT</code> /info /info/{id} <code>DELETE</code> /info /info/{id} <code>GET</code> /inboundinventory /inbound-inventory <code>POST</code> /inboundinventory /inbound-inventory <code>GET</code> ~ /inbound-inventory/{id} <code>PUT</code> /inboundinventory /inbound-inventory/{id} <code>DELETE</code> /inboundinventory /inbound-inventory/{id}"},{"location":"changes-v1-to-v2.html#unmanaged","title":"Unmanaged","text":"<p>Path: <code>/amazon/{version}/unmanaged</code></p> Methods v1 v2 Changed Endpoint Json(In/Out) <code>GET</code> ~ /asins <code>POST</code> ~ /asins <code>GET</code> ~ /asins/{id} <code>PUT</code> ~ /asins/{id} <code>DELETE</code> ~ /asins/{id} <code>PATCH</code> ~ /asins/batch <code>GET</code> ~ /asins/batch/{id} <code>GET</code> ~ /campaigns <code>POST</code> ~ /campaigns <code>GET</code> ~ /campaigns/{id} <code>PUT</code> ~ /campaigns/{id} <code>DELETE</code> ~ /campaigns/{id} <code>PATCH</code> ~ /campaigns/batch <code>GET</code> ~ /campaigns/batch/{id}"},{"location":"changes-v1-to-v2.html#report","title":"Report","text":"<p>Path: <code>/amazon/v2/report</code></p> Methods v1 v2 Changed Endpoint Json(In/Out) <code>POST</code> ~ /keyword_branded_competitor <code>GET</code> ~ /dowload/{id}"},{"location":"changes-v1-to-v2.html#walmart-api","title":"Walmart API","text":"<p>The Walmart API was released in the Quartile openapi v2.</p>"},{"location":"changes-v1-to-v2.html#report_1","title":"Report","text":"<p>Path: <code>/walmart/v2/report</code></p> Methods v1 v2 Changed Endpoint Json(In/Out) <code>POST</code> ~ /adgroup <code>GET</code> ~ /adgroup <code>POST</code> ~ /aditem <code>GET</code> ~ /aditem"},{"location":"tutorial/index.html","title":"About","text":""},{"location":"tutorial/index.html#subscriber-and-authorization","title":"Subscriber and Authorization","text":"<p>Access Control (Subscriber) and Authorization (OAuth2), by default, all the requests to our API require a subscriber key and authorization token.</p> <p>You will learn how to get a subscriber key and authorization token in the following steps.</p>"},{"location":"tutorial/index.html#subscriber-key","title":"Subscriber Key","text":"<p>The subscriber is used to:</p> <ul> <li>Access control on the API<ul> <li>Control requests,</li> <li>Reports,</li> <li>Limits and access products.</li> </ul> </li> </ul> <p>Subscriber Key</p> <p>The subscriber key is required to access our API.</p> <p>P.S.: A subscriber key is 32-character alphanumeric text that contains a value that uniquely identifies a subscriber in our API.</p> <p>The Subscriber Key is sent in the request header.</p> <p>For example:</p> <pre><code>GET /amazon/v2/ HTTP/1.1\nHost: api.quartile.com\nContent-Type: application/json\nAuthorization: Bearer eyJ0eXA...\nSubscription-Key: &lt;your_subscription_key&gt;  \n</code></pre>"},{"location":"tutorial/index.html#authorization-oauth2","title":"Authorization (OAuth2)","text":"<p>The authorization token is used to validate your identity in Quartile LLC, this token is required to access our API.</p> <p>Authorization Token</p> <p>The authorization token is required to access our API.</p> <p>P.S: An authorization code is an alphanumeric password that authorizes your user to search, change, delete, or enter information into a security-protected API.</p> <p>The Authorization Token is sent in the request header.</p> <p>For example:</p> <pre><code>GET /amazon/v2/ HTTP/1.1\nHost: api.quartile.com\nContent-Type: application/json\nAuthorization: Bearer &lt;your_authorization_token&gt;\nSubscription-Key: xyxysc98eud840afecc241f7ru3jnxyz\n</code></pre>"},{"location":"tutorial/about-subscription.html","title":"Subscription","text":"<p>The 'subscription key' is a unique identifier for your Quartile account. It is used to authenticate your requests to the Quartile API. This key can be created following the previous step.</p> <p>The subscription controls your access to our gateway.</p> <p>A subscription can only be used when activated by Quartile.</p>"},{"location":"tutorial/about-subscription.html#using-the-subscription-key","title":"Using the subscription key","text":"<p>After activating a subscription through Quartile, you can use it in the request header as a <code>Subscription-Key</code> in API v2 and <code>Ocp-Apim-Subscription-Key</code> in API v1.</p>"},{"location":"tutorial/about-subscription.html#example","title":"Example","text":"<p>Change the <code>&lt;subscription_key&gt;</code> and <code>&lt;access_token&gt;</code> to your own values.</p> v2v1 <pre><code>GET /amazon/v2/accounts HTTP/1.1\nHost: api.quartile.com\nSubscription-Key: &lt;subscription_key&gt;\nAuthorization: Bearer &lt;access_token&gt;\n</code></pre> <pre><code>GET /amazon/v1/accounts HTTP/1.1\nHost: api.quartile.com\nOcp-Apim-Subscription-Key: &lt;subscription_key&gt;\nAuthorization: Bearer &lt;access_token&gt;\n</code></pre>"},{"location":"tutorial/about-tokens.html","title":"Tokens","text":""},{"location":"tutorial/about-tokens.html#token-lifetimes","title":"Token lifetimes","text":"<p>The following token lifetimes are provided to further your knowledge. They can help you when you develop and debug apps. Note that your apps should not be written to expect any of these lifetimes to remain constant. They can and will change if an anomaly is identified.</p> Token Lifetime Description Access tokens Up to 12 hours Access token are typically valid for 12 hours. Your web app can use this lifetime to maintain its own sessions with users (recommended).You cannot currently choose a different session duration. If your app needs to get a new access token, you can generate a new set of tokens using refresh token. Refresh tokens Up to 14 days A single refresh token is valid for a maximum of 14 days. However, a refresh token may become invalid at any time for any number of reasons (For example: You generated multiple sets of tokens using the same token). Your app should continue to try to use a refresh token until the request fails, or until your app replaces the refresh token with a new one."},{"location":"tutorial/about-tokens.html#using-the-access-token","title":"Using the access token","text":"<p>The access token is passed in the request's Authorization header, as a Bearer token.</p>"},{"location":"tutorial/about-tokens.html#example","title":"Example","text":"<p>Change the <code>&lt;subscription_key&gt;</code> and <code>&lt;access_token&gt;</code> to your own values.</p> v2v1 <pre><code>GET /amazon/v2/accounts HTTP/1.1\nHost: api.quartile.com\nSubscription-Key: &lt;subscription_key&gt;\nAuthorization: Bearer &lt;access_token&gt;\n</code></pre> <pre><code>GET /amazon/v1/accounts HTTP/1.1\nHost: api.quartile.com\nOcp-Apim-Subscription-Key: &lt;subscription_key&gt;\nAuthorization: Bearer &lt;access_token&gt;\n</code></pre>"},{"location":"tutorial/auth-subscriber.html","title":"Create","text":""},{"location":"tutorial/auth-subscriber.html#create-subscriber","title":"Create Subscriber","text":"<p>The user can subscribe to any product but cannot have more than one active key for each product. All keys must be approved (activated by Quartile), activation deadline is 24 hours after creation.</p>"},{"location":"tutorial/auth-subscriber.html#subscribe-to-a-product","title":"Subscribe to a product","text":""},{"location":"tutorial/auth-subscriber.html#access-the-products-page","title":"Access the products page","text":"<p>Go to Products by clicking on the menu. </p> <p></p>"},{"location":"tutorial/auth-subscriber.html#click-on-a-product","title":"Click on a product","text":"<p>All products will be listed; you can click on a product, for example, Advertising API.</p> <p></p>"},{"location":"tutorial/auth-subscriber.html#subscribe-to-the-product","title":"Subscribe to the product","text":"<p>Fill in the field with the name you want to call the key and click Sign Up!</p> <p></p>"},{"location":"tutorial/auth-subscriber.html#check-your-keys","title":"Check Your Keys","text":"<p>Access Profile. Verify that your key was created. All keys starting with State Submitted; only after Quartile's approval will you be able to use them.</p> <p></p>"},{"location":"tutorial/batch-process.html","title":"Batch processing","text":"<p>Batch processing is a way to process multiple <code>resources</code> in a single request. This is useful when you need to process a lot of <code>resources</code>; instead of submitting multiple requests, you can send in batches of up to 100 <code>resources</code> at a time.</p> <p>Note</p> <p>Batch processing is only available for some resources. See the v2 - Changes for more information.</p>"},{"location":"tutorial/batch-process.html#batch-processing-overview","title":"Batch processing overview","text":"<p>Some resources have batch processing endpoints.</p> <p>The batch processing endpoint is <code>/batch</code>. It accepts a <code>PATCH</code> request with a JSON body containing an array of <code>resources</code> to be processed. Each <code>resource</code> is a JSON object. After the request is submitted, the response will contain a <code>batchId</code> that can be used to retrieve the results of the batch processing. Use the endpoint <code>/batch/{batchId}</code> to retrieve the results of the batch processing.</p> <p>Diagram of batch processing</p> <p> </p> Batch processing diagram"},{"location":"tutorial/batch-process.html#batch-processing-request","title":"Batch processing request","text":"<p>This request is an example of a batch processing request for the <code>masterlist</code> resource.</p>"},{"location":"tutorial/batch-process.html#patch","title":"PATCH","text":""},{"location":"tutorial/batch-process.html#request","title":"Request","text":"<pre><code>PATCH /amazon/v2/process/masterlist HTTP/1.1\nHost: api.quartile.com\nContent-Type: application/json\nSubscription-Key: &lt;subscription_key&gt;\nAuthorization: Bearer &lt;access_token&gt;\n\n[\n    {   \n        \"asin\": \"ASINXYZXPTO1\", \n        \"countryCode\": \"US\", \n        \"percACoS\": 2.7\n    }\n]\n</code></pre>"},{"location":"tutorial/batch-process.html#response","title":"Response","text":"<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"batchId\": \"5349b4ddd2781d08c09890f3\"\n}\n</code></pre>"},{"location":"tutorial/batch-process.html#get","title":"GET","text":"<p>Returns the status of a batch process. The batch process is asynchronous, so it may take a while to complete.</p> <p>The status_code and status can be:</p> <ul> <li><code>206-PENDING</code>: the batch is in the queue waiting to be processed.</li> <li><code>206-RUNNING</code>: the batch is being processed.</li> <li><code>206-PARTIAL</code>: the batch has been processed partially.</li> <li><code>206-FAILED</code>: the batch has failed to be processed completely.</li> <li><code>200-SUCCESS</code>: the batch has been processed successfully.</li> </ul> <p>After the batch is processed, the response will contain a list of objects. The list with the status per item will be returned when the processing status is FAILED, SUCCESS, or PARTIAL.</p>"},{"location":"tutorial/batch-process.html#request_1","title":"Request","text":"<pre><code>GET /amazon/v2/batch/{batchId} HTTP/1.1\nHost: api.quartile.com\nContent-Type: application/json\nSubscription-Key: &lt;subscription_key&gt;\nAuthorization: Bearer &lt;access_token&gt;\n</code></pre>"},{"location":"tutorial/batch-process.html#response_1","title":"Response","text":""},{"location":"tutorial/batch-process.html#example-200-status-code","title":"Example: 200-Status Code","text":"<pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"batchId\": \"5349b4ddd2781d08c09890f3\",\n    \"status\": \"SUCCESS\",\n    \"data\": [\n        {\n            \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n            \"asin\": \"ASINXYZXPTO1\", \n            \"countryCode\": \"US\", \n            \"percACoS\": 2.7\n            \"status\": {\n                \"success\": true,\n                \"message\": \"successfully\",\n                \"process\": \"INSERT\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"tutorial/batch-process.html#example-206-status-code","title":"Example: 206-Status Code","text":"<pre><code>HTTP/1.1 206 Partial Content\nContent-Type: application/json\n\n{\n  \"detail\": \"processing\",\n  \"status\": \"PENDING\"\n}\n</code></pre>"},{"location":"tutorial/intro.html","title":"Intro - First Access","text":""},{"location":"tutorial/intro.html#first-access","title":"First Access","text":"<p>The first access to the Quartile Developer Portal is done through the Quartile account, the same used to access the Quartile Portal. </p>"},{"location":"tutorial/intro.html#create-a-developer-account","title":"Create a developer account","text":"<p>Access the Quartile Developer Portal</p> <p>Use the same email and password used to access the Quartile Portal.</p>"},{"location":"tutorial/intro.html#click-on-sign-in","title":"Click on \"Sign In\".","text":""},{"location":"tutorial/intro.html#login","title":"Login","text":"<p>Make the login using your Quartile account.</p> <p></p>"},{"location":"tutorial/intro.html#sign-in","title":"Sign in","text":"<p>Make the sign-in using your email and password registered in the Quartile.</p> <p></p>"},{"location":"tutorial/intro.html#complete-the-form","title":"Complete the form","text":"<p>Fill in the email field with the email you used in the previous step.</p> <p>After filling in the data, click the \"Sign Up\" button.</p> <p></p>"},{"location":"tutorial/intro.html#verify-subscriber","title":"Verify subscriber","text":"<p>After registration, it is necessary to validate your subscription. Check your email; you will receive the confirmation.</p>"},{"location":"tutorial/openapi-postman.html","title":"Postman","text":"<p>Postman is an API platform for building and using APIs. Postman simplifies each step of the API lifecycle and streamlines collaboration so you can create better APIs\u2014faster.</p> <p>Use Postman with an alternative to test and copy the endpoint call.</p>"},{"location":"tutorial/openapi-postman.html#export-the-openapijson-file-from-the-developer-portal","title":"Export the openapi.json file from the Developer Portal.","text":""},{"location":"tutorial/openapi-postman.html#import-into-postman","title":"Import into Postman.","text":"<p>Postman tutorial - Click here</p> <p> P.S.: References</p>"},{"location":"tutorial/openapi-spec.html","title":"Specification","text":"<p>The OpenAPI Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined, a consumer can understand and interact with the remote service with a minimal amount of implementation logic.</p> <p>An OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.</p> <p> P.S.: References</p>"},{"location":"tutorial/portal-api-code.html","title":"Export example","text":"<p>You can copy the code of the call to the language of your choice.</p>"},{"location":"tutorial/portal-api-code.html#select-language","title":"Select language","text":""},{"location":"tutorial/portal-api-code.html#copy-code","title":"Copy code","text":""},{"location":"tutorial/portal-api.html","title":"Dev portal","text":""},{"location":"tutorial/portal-api.html#quartile-developer-portal","title":"Quartile Developer Portal","text":"<p>Quartile Dev Portal has a simple option for you to make requests in our API and export code examples in Java, C#, Python, PHP etc.</p> <p>Log in to the developer portal and go to the API page..</p>"},{"location":"tutorial/portal-api.html#access-api","title":"Access API","text":""},{"location":"tutorial/portal-api.html#select-an-api","title":"Select an API","text":""},{"location":"tutorial/portal-api.html#select-an-endpoint","title":"Select an Endpoint","text":""},{"location":"tutorial/portal-api.html#see-requirements-for-request","title":"See requirements for request","text":"<p>All request parameters have a predescription of what that field is.</p> <p></p>"},{"location":"tutorial/portal-api.html#what-will-return","title":"What will return?","text":"<p>Before making a request you can see what the endpoint should return. Scroll down to the response part, you can see what the status and return type of this endpoint is.</p>"},{"location":"tutorial/portal-api.html#successfull-response","title":"Successfull response","text":""},{"location":"tutorial/portal-api.html#unauthorized","title":"Unauthorized","text":""},{"location":"tutorial/portal-api.html#unprocessable-entity","title":"Unprocessable Entity","text":""},{"location":"tutorial/portal-api.html#try-it","title":"Try it","text":"<p>Make the request by clicking on Try it</p>"},{"location":"tutorial/portal-api.html#click-on-the-button-try-it","title":"Click on the button Try it","text":""},{"location":"tutorial/portal-api.html#select-authorization_code","title":"Select authorization_code","text":"<p>If it is the first access, a window will open for you to login to generate an access token,  after login the dev portal will automatically set an access token in your requests.</p>"},{"location":"tutorial/portal-api.html#generate-token-automatically","title":"Generate token automatically","text":""},{"location":"tutorial/portal-api.html#after-generate-token","title":"After generate token","text":"<p>The access token will be automatically set in the request header.</p> <p></p>"},{"location":"tutorial/portal-api.html#select-subscription-key","title":"Select subscription key","text":"<p>The subscription key is automatically set if you have a Quartile-enabled key for your access.</p> <p></p>"},{"location":"tutorial/portal-api.html#set-the-profileid","title":"Set the profileId","text":"<p>Case you don't have the profileId, you can get using the endpoint /amazon/{version}/accounts.</p> <p></p>"},{"location":"tutorial/portal-api.html#send-request","title":"Send request","text":"<p>When you click on the button Send, the request will be sent and the response will be displayed.</p> <p></p>"},{"location":"tutorial/portal-api.html#see-the-response","title":"See the response.","text":"<p>The response will be displayed in the response part.</p> <p></p>"},{"location":"tutorial/tokens-v1.html","title":"v1(deprecated)","text":""},{"location":"tutorial/tokens-v1.html#v1deprecated-authorization","title":"v1(deprecated) - Authorization","text":"<p>OAuth2 JWT authorization is a secure way to transfer your personal data and validate your identity.</p> <p>By default you need to create a set of tokens. In this set of tokens, you will receive an authorization token and a refresh token.</p> <ul> <li> <p>Authorization Token: Use this token to make API request! Send this token in the request header. The token expires in 720 minutes (12 hours) after being created.</p> </li> <li> <p>Refresh Token: Use this token to request a new set of tokens. Token expires in 14 days after being created.</p> </li> </ul> <p>Warning  Refresh token</p> <p>When the access token expires and you request a new set of tokens, the refresh token will also be updated! So always save the last refresh token, so you won't have any problems. The refresh token may expire or be disabled when you request a new set of tokens!</p> <p>You can learn how to deal with this \"problem\" in the session: Updating tokens</p>"},{"location":"tutorial/tokens-v1.html#access-profile","title":"Access Profile","text":"<p>After login, to to the \"profile\" page. You will see a \"Generate Token\" button, click this button. You will be redirected to new page where you can generate token.</p>"},{"location":"tutorial/tokens-v1.html#generate-token","title":"Generate Token","text":""},{"location":"tutorial/tokens-v1.html#login","title":"Login","text":"<p>Fill in Quartile email and password, click on \"sign in\".</p> <p></p>"},{"location":"tutorial/tokens-v1.html#response","title":"Response","text":"<p>If you have logged in correctly, a set of tokens will be generated.</p> <pre><code>{\n    \"authorization\": {\n        \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6I...\",\n        \"type\": \"Bearer\",\n        \"expires_in\": 43200,\n        \"expires_at\": \"2022-06-10T17:08:48\",\n        \"not_before\": 1627058225,\n        \"note\": \"Use this token to make the request in the API...\"\n    },\n    \"refresh\": {\n        \"token\": \"eyJraWQiOiJjcGltY29yZV8wOTI1MjAxNSIsInZlciI6Ij...\",\n        \"expires_in\": 1209600,\n        \"expires_at\": \"2022-06-24T17:08:48\",\n        \"note\": \"Use refresh_token to request a new set of tokens. \n        When the access token expires and you request a new set of tokens,\n        the refresh token will also be updated! So always save the last refresh token,\n        so you won't have any problems. The refresh token may expire or be disabled when\n        you request a new set of tokens\"\n    }\n}\n</code></pre>"},{"location":"tutorial/tokens-v1.html#endpoints","title":"Endpoints","text":"<p>Although the \"Authorization\" url is available, you don't need to use it because you will use the dev portal to generate a new set of tokens.  With the generated tokens you can make API calls and request new tokens through the refresh endpoint. </p> <p>Access: OAuth API </p> Method Type URL Description <code>GET</code> Authorization  /auth/v1/token?code={code} The authorize token, normally the user with a customer profile does not have access to this data. If this is the case, you can obtain new tokens in the Tokens - Developer Portal &gt; Profile. <code>POST</code> Refresh  /auth/v1/refresh-token You need to enter the update token. If you do not have this data, \"log in\" again on the portal and request a new set of tokens (authorization token and refresh token). Always save the last refresh token to use next time. <code>POST</code> Validade  /auth/v1/validate-token You can verify that the authorization token is valid."},{"location":"tutorial/tokens-v2.html","title":"v2","text":""},{"location":"tutorial/tokens-v2.html#v2-authorization","title":"v2 - Authorization","text":"<p>OAuth2 JWT authorization is a secure way to transfer personal data and validate identity.</p> <p>In this new version, you can use the <code>/login</code> endpoint to log in and generate a new set of tokens.</p> <p>Warning</p> <p>The access token and authorization token are the same thing. </p> <ul> <li> <p>Authorization Token: Use this token to make requests to our API! Send this token in the request header. The token expires 720 minutes (12 hours) after it is created.</p> </li> <li> <p>Refresh Token: Use this token to request a new set of tokens. This token expires 14 days after being created.</p> </li> </ul> <p>Warning  Refresh token</p> <p>When the access token expires and you request a new set of tokens, the refresh token will also be updated! So always save the last refresh token, so you won't have any problems. The refresh token may expire or be disabled when you request a new set of tokens!</p> <p>You can learn how to deal with this \"problem\" in the session: Updating tokens</p> <p>Deprecated </p> <p>The old version(v1) of the authorization is still available, but it will be deprecated in the future.  We recommend that you use the new version(v2) of the authorization.</p>"},{"location":"tutorial/tokens-v2.html#login","title":"Login","text":"<p>After creating an account in the Developer Portal, you can use the login endpoint to generate a new set of tokens.</p> <p>Info </p> <p>The login endpoint is available from the OAuth API on the Developer Portal.</p> <p>Make a <code>POST</code> request to the login endpoint. Change the <code>&lt;your@email.com&gt;</code> and <code>&lt;your_password&gt;</code> with your email and password. Remember to use the same email and password you used to log in to your account in the Developer Portal.</p> <pre><code>POST /auth/v2/login HTTP/1.1\nHost: api.quartile.com\nContent-Type: application/json\nSubscription-Key: &lt;subscription_key&gt;\n\n{\n    \"username\": \"&lt;your@email.com&gt;\",\n    \"password\": \"&lt;your_password&gt;\"\n}\n</code></pre>"},{"location":"tutorial/tokens-v2.html#response","title":"Response","text":"<p>If you have logged in correctly, a set of tokens will be generated.</p> <pre><code>{\n    \"authorization\": {\n        \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6I...\",\n        \"type\": \"Bearer\",\n        \"expires_in\": 43200,\n        \"expires_at\": \"2022-06-10T17:08:48\",\n        \"not_before\": 1627058225,\n        \"note\": \"Use this token to make the request in the API...\"\n    },\n    \"refresh\": {\n        \"token\": \"eyJraWQiOiJjcGltY29yZV8wOTI1MjAxNSIsInZlciI6Ij...\",\n        \"expires_in\": 1209600,\n        \"expires_at\": \"2022-06-24T17:08:48\",\n        \"note\": \"Use refresh_token to request a new set of tokens. \n        When the access token expires and you request a new set of tokens,\n        the refresh token will also be updated! So always save the last refresh token,\n        so you won't have any problems. The refresh token may expire or be disabled when\n        you request a new set of tokens\"\n    }\n}\n</code></pre>"},{"location":"tutorial/tokens-v2.html#endpoints","title":"Endpoints","text":"<p>You can make API calls and request new tokens through the refresh endpoint with the generated tokens. </p> <p>Access: OAuth API </p> Method Type URL Description <code>POST</code> Login  /auth/v2/login The login endpoint is used to generate a new set of tokens. You can use the generated tokens to make API calls. <code>POST</code> Refresh  /auth/v2/refresh You need to enter the update token. If you do not have this data, make a new login using the <code>/login</code> endpoint. Always save the last refresh token to use next time. <code>POST</code> Validade  /auth/v2/validate You can verify that the authorization token is valid."},{"location":"tutorial/updating-tokens.html","title":"Updating tokens","text":"<p>The OAuth2 system is premised on having a token expiration process.</p> <p>This can cause problems when you need to call a service asynchronously many times. In this period of time the access token may expire.</p> <p>This tutorial provides a way to deal with this problem.</p>"},{"location":"tutorial/updating-tokens.html#solving","title":"Solving","text":"<ul> <li>Database to save the tokens.</li> <li>Worker to update the refresh token when there is 1 hour left to expire.</li> <li>Microservice to provide the most up-to-date token.</li> </ul>"},{"location":"tutorial/updating-tokens.html#using-python-and-postgresql","title":"Using Python and PostgreSQL","text":"<p>This example uses Python as the programming language and PostgreSQL as the database.</p>"},{"location":"tutorial/updating-tokens.html#github-code","title":"GitHub - Code","text":"<p>This GitHub folder has all the files mentioned in the tutorial.</p> <p>GitHub </p>"},{"location":"tutorial/updating-tokens.html#install-dependencies","title":"Install Dependencies","text":"<p>The dependencies used in this tutorial are:</p> <ul> <li>pysqlx-engine: SQL Engine</li> <li>httpx: HTTP Client</li> </ul> <pre><code>$ pip install httpx pysqlx-engine\nRequirement already satisfied: httpx in ./.pyenv/versions/3.10.1/lib/python3.10/site-packages (1.4.36)\nCollecting pysqlx-engine\n  Downloading pysqlx_engine-2.9.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.0 MB)\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 3.0/3.0 MB 25.9 MB/s eta\n...\n...\n</code></pre>"},{"location":"tutorial/updating-tokens.html#file-structure","title":"File Structure","text":"<p>The file structure is as follows:</p> <pre><code>.\n\u251c\u2500 database.py\n\u251c\u2500 schema.py\n\u251c\u2500 consumer.py\n\u2514\u2500 worker.py\n</code></pre>"},{"location":"tutorial/updating-tokens.html#code","title":"Code","text":""},{"location":"tutorial/updating-tokens.html#databasepy","title":"database.py","text":"<p>This file contains the database connection and the class that represents the table.</p> <p>The <code>TokenDB</code> class will be used to save the tokens in the database.</p> database.py<pre><code>from datetime import datetime\nfrom pysqlx_engine import PySQLXEngineSync, BaseRow\nfrom pydantic import Field, Json\nfrom uuid import UUID\nfrom os import environ\n\nQUARTILE_ID = \"febdb7d2-e95d-11ed-9255-65636df51340\"\n\"\"\"\nThis is the id of the row that will be used to store the tokens.\n\nThis is a constant value and should not be changed.\n\"\"\"\n\n\nclass TokenTable(BaseRow):\n    id: UUID = QUARTILE_ID\n    access_token: str\n    access_token_expires: int\n    refresh_token: str\n    updating: bool\n    json_data: Json\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n\n\nclass TokenDB:\n    def __init__(self):\n        \"\"\"\n        getenv(\"DATABASE_URL\") is used to get the database url\n        from the environment variables.\n\n        example: postgresql://USER:PASSWORD@HOST:PORT/DATABASE\n        \"\"\"\n        self.uri = environ[\"DATABASE_URL\"]\n        self.db = PySQLXEngineSync(uri=self.uri)\n        self.db.connect()\n\n    def create_table(self):\n        \"\"\"\n        Creating the table if it does not exist.\n        \"\"\"\n        sql = \"\"\"\n            CREATE TABLE IF NOT EXISTS quartile_tokens (\n                id UUID NOT NULL, \n                access_token TEXT, \n                refresh_token TEXT, \n                access_token_expires INTEGER, \n                updating BOOLEAN, \n                json_data JSON, \n                created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL, \n                updated_at TIMESTAMP WITHOUT TIME ZONE NOT NULL, \n                PRIMARY KEY (id)\n            );\n        \"\"\"\n        self.db.execute(sql=sql)\n\n    def select_by_id(self, id: UUID) -&gt; TokenTable:\n        \"\"\"\n        Selecting a token by id from the database and\n        returning it as an instance of the TokenTable class.\n        \"\"\"\n        sql = \"SELECT * FROM quartile_tokens WHERE id = :id;\"\n        return self.db.query_first(\n            sql=sql,\n            parameters={\"id\": id},\n            model=TokenTable,\n        )\n\n    def insert(self, data: TokenTable) -&gt; TokenTable:\n        \"\"\"\n        Inserting tokens and json_data on the database.\n        \"\"\"\n        sql = \"\"\"\n            INSERT INTO quartile_tokens (\n                id,\n                access_token,\n                refresh_token,\n                access_token_expires,\n                updating,\n                json_data,\n                created_at,\n                updated_at\n            ) VALUES (\n                :id,\n                :access_token,\n                :refresh_token,\n                :access_token_expires,\n                :updating,\n                :json_data,\n                :created_at,\n                :updated_at\n            );\n        \"\"\"\n        params = data.dict()\n        self.db.execute(sql=sql, parameters=params)\n        return self.select_by_id(id=data.id)\n\n    def update(self, data: TokenTable) -&gt; TokenTable:\n        \"\"\"\n        Updating tokens and json_data on the database.\n        \"\"\"\n        sql = \"\"\"\n            UPDATE quartile_tokens SET\n                access_token            = :access_token,\n                refresh_token           = :refresh_token,\n                access_token_expires    = :access_token_expires,\n                updating                = :updating,\n                json_data               = :json_data,\n                updated_at              = :updated_at\n            WHERE id                    = :id;\n        \"\"\"\n        params = data.dict()\n        self.db.execute(sql=sql, parameters=params)\n        return self.select_by_id(id=data.id)\n\n    def update_status(self, id: UUID, updating: bool) -&gt; TokenTable:\n        \"\"\"\n        Updating status is used to prevent multiple requests to the API.\n        When updating is True, the API will not be called.\n        \"\"\"\n\n        sql = \"\"\"\n            UPDATE quartile_tokens SET\n                updating    = :updating,\n                updated_at  = :updated_at\n            WHERE id        = :id;\n        \"\"\"\n        params = {\"id\": id, \"updating\": updating, \"updated_at\": datetime.now()}\n        self.db.execute(sql=sql, parameters=params)\n        return self.select_by_id(id=id)\n</code></pre>"},{"location":"tutorial/updating-tokens.html#schemapy","title":"schema.py","text":"<p>This file contains the models that represent the tokens.</p> <p>The <code>AuthToken</code> class will be used to parse the response from the Quartile API.</p> schema.py<pre><code>from datetime import datetime\nfrom pydantic import BaseModel as _BaseModel, Field\n\nclass BaseModel(_BaseModel):\n    class Config:\n        orm_mode = True\n        ignore_extra = True\n        allow_population_by_field_name = True\n        arbitrary_types_allowed = True\n\n\nclass Authorization(BaseModel):\n    token: str\n    type: str\n    expires_in: int = Field(..., alias=\"expiresIn\")\n    expires_at: datetime = Field(..., alias=\"expiresAt\")\n    not_before: int = Field(..., alias=\"notBefore\")\n    note: str\n\n\nclass Refresh(BaseModel):\n    token: str\n    expires_in: int = Field(..., alias=\"expiresIn\")\n    expires_at: datetime = Field(..., alias=\"expiresAt\")\n    note: str\n\n\nclass AuthToken(BaseModel):\n    authorization: Authorization\n    refresh: Refresh\n</code></pre>"},{"location":"tutorial/updating-tokens.html#consumerpy","title":"consumer.py","text":"<p>This file contains the code that will consume the token, and you can see that the token is returned when the <code>updating</code> field is <code>False</code>!</p> <p>This status is changed by <code>worker.py</code> when the token is updated.</p> consumer.py<pre><code>import logging\nfrom time import sleep\n\nfrom database import QUARTILE_ID, TokenDB\nfrom schema import AuthToken\n\nlogging.basicConfig(level=logging.INFO)\n\n\ndef get_access_token() -&gt; AuthToken:\n    \"\"\"\n    Gets an access token from the TokenDB.\n\n    This function continuously checks the TokenDB for an available access\n    token by calling the select_by_status method of the TokenDB class.\n\n    If an access token is found, it is returned as an instance of the AuthToken class.\n    If no access token is found, the function waits for 5 seconds and tries again.\n\n    Returns:\n        AuthToken: An instance of the AuthToken class representing the Quartile token.\n\n    \"\"\"\n    while True:\n        logging.info(\"getting token...\")\n        resp = TokenDB().select_by_id(id=QUARTILE_ID)\n\n        # check if resp is not None and resp.updating is False\n        if resp and resp.updating is False:\n            logging.info(\"token found.\")\n            return AuthToken.parse_obj(resp.json_data)\n\n        logging.info(\"token not found ot updating, waiting 5 seconds...\")\n        sleep(5)\n\n\nif __name__ == \"__main__\":\n    data = get_access_token()\n    logging.info(data.json(indent=4))\n</code></pre>"},{"location":"tutorial/updating-tokens.html#workerpy","title":"worker.py","text":"<p>The <code>worker.py</code> is responsible for updating the token when it is about to expire.</p> <p>The access token expires in 12 hours, so the worker will update the token when there is 1 hour left to expire.</p> <p>For example, you can put on the worker a scheduler to run every 30 minutes. Or you can run it in a separate process.</p> <p>Some cloud companies provide simple ways to run this kind of routine using a timer trigger, for example:</p> <ul> <li>AWS Lambda</li> <li>Google Cloud Functions</li> <li>Azure Functions</li> </ul> worker.py<pre><code>from datetime import datetime, timedelta\nimport logging\n\nimport httpx\nfrom os import environ\nfrom database import QUARTILE_ID, TokenDB, TokenTable\nfrom schema import AuthToken\n\nlogging.basicConfig(level=logging.INFO)\n\n# This is the base uri for the Quartile API.\nBASE_URI = \"https://api.quartile.com/auth/v2\"\n# set your subscription key in your environment variables,\n# You can find your subscription key in the Developer Portal.\nSUBSCRIPTION_KEY = environ[\"QUARTILE_SUBSCRIPTION_KEY\"]\n# set your username(email) in your environment variables, the same used in the Portal\nUSERNAME = environ[\"QUARTILE_YOUR_USERNAME\"]\n# set your password in your environment variables, the same used in the Portal\nPASSWORD = environ[\"QUARTILE_YOUR_PASSWORD\"]\n\n\n# HTTP - API\ndef login() -&gt; AuthToken:\n    uri = f\"{BASE_URI}/login\"\n    body = {\"username\": USERNAME, \"password\": PASSWORD}\n    headers = {\"Subscription-Key\": SUBSCRIPTION_KEY}\n    resp = httpx.post(url=uri, json=body, headers=headers, timeout=10)\n\n    logging.info(f\"login... return status code: {resp.status_code}\")\n    assert resp.status_code == 201, resp.text\n\n    data = resp.json()\n    return AuthToken.parse_obj(data)\n\n\ndef refresh_tokens(refresh_token: str) -&gt; AuthToken:\n    uri = f\"{BASE_URI}/refresh\"\n    body = {\"token\": refresh_token}\n    headers = {\"Subscription-Key\": SUBSCRIPTION_KEY}\n    resp = httpx.post(url=uri, json=body, headers=headers, timeout=10)\n\n    logging.info(f\"refreshing tokens... return status code: {resp.status_code}\")\n    assert resp.status_code == 201, resp.text\n\n    data = resp.json()\n    return AuthToken.parse_obj(data)\n\n\n# DATABASE - POSTGRES\ndef insert_token(db: TokenDB):\n    tokens = login()\n\n    data = TokenTable(\n        id=QUARTILE_ID,\n        access_token=tokens.authorization.token,\n        access_token_expires=tokens.authorization.expires_at.timestamp(),\n        refresh_token=tokens.refresh.token,\n        updating=False,\n        json_data=tokens.json(),\n    )\n\n    db.insert(data=data)\n    logging.info(\"tokens inserted\")\n\n\ndef update_token(db: TokenDB, row: TokenTable):\n    # get new set of tokens\n    try:\n        tokens = refresh_tokens(refresh_token=row.refresh_token)\n        logging.info(\"tokens refreshed\")\n    except AssertionError:\n        # if the refresh token is expired, then make a \n        # login request to get a new set of tokens.\n        logging.info(\"refresh token expired, getting new tokens...\")\n        tokens = login()\n        logging.info(\"tokens refreshed\")\n\n    data = TokenTable(\n        id=QUARTILE_ID,\n        access_token=tokens.authorization.token,\n        access_token_expires=tokens.authorization.expires_at.timestamp(),\n        refresh_token=tokens.refresh.token,\n        updating=False,\n        json_data=tokens.json(),\n    )\n\n    # update tokens\n    db.update(data=data)\n    logging.info(\"tokens updated\")\n\n\n# MAIN\ndef main():\n    logging.info(\"starting worker...\")\n    # create a new instance of TokenDB class\n    db = TokenDB()\n\n    # try create quartile_tokens table if not exists,\n    # you can remove this line if you already have the table\n    db.create_table()\n\n    # get one row if the QUARTILE_ID is equal to the id column\n    row = db.select_by_id(id=QUARTILE_ID)\n\n    # case the row is None, then make a login request to get a new set of tokens.\n    if row is None:\n        logging.info(\"inserting tokens...\")\n        insert_token(db=db)\n        return  # exit the function\n\n    # get datetime utc now minus 1 hour\n    now = int((datetime.utcnow() - timedelta(hours=1)).timestamp())\n\n    # check if the access_token_expires is greater than or equal now minus 5\n\n    if row.access_token_expires &lt;= now:\n        logging.info(\"updating tokens...\")\n        # change status to updating\n        # this will prevent the consumer function to get the invalid token\n        db.update_status(id=QUARTILE_ID, updating=True)\n\n        # try to update the tokens\n        update_token(db=db, row=row)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorial/updating-tokens.html#run-the-code","title":"Run the code","text":"Terminal 1:  worker.pyTerminal 2:  consumer.py <pre><code>$ python worker.py\n\nwaiting for token update...\n...\n</code></pre> <pre><code>$ python consumer.py\n\ngetting token...\n...\n</code></pre>"},{"location":"tutorial/python/tokens/readme.html","title":"Updating tokens","text":""},{"location":"tutorial/python/tokens/readme.html#updating-tokens","title":"Updating tokens","text":"<p>Tokens are used to authenticate users and services. In this folder, you can find the code to generate and verify tokens.</p> <p>The <code>consumer.py</code> is an example of how to get the access token from the database. The <code>worker.py</code> is an example of how to update the token in the database.</p>"},{"location":"tutorial/python/tokens/readme.html#postgresql","title":"PostgreSQL","text":"<p>The tokens are stored in the database.</p> <p>You can use the command below to create the docker container with the database.</p> <pre><code>docker run --name postgres \\\n    -e POSTGRES_USER=postgres \\\n    -e POSTGRES_PASSWORD=postgres \\\n    -e POSTGRES_DB=quartile \\\n    -p 5432:5432 \\\n    -d postgres\n</code></pre>"}]}